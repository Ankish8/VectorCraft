<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VectorCraft 2.0</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <style>
        .slider {
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            border-radius: 3px;
            background: #e5e7eb;
            outline: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #6366f1;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .upload-area {
            transition: all 0.2s ease;
        }
        .upload-area:hover {
            border-color: #6366f1;
            background-color: #f8fafc;
        }
        
        /* Professional SVG Viewer Styles */
        #svgViewerContainer {
            background-image: 
                linear-gradient(45deg, #f0f0f0 25%, transparent 25%), 
                linear-gradient(-45deg, #f0f0f0 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, #f0f0f0 75%), 
                linear-gradient(-45deg, transparent 75%, #f0f0f0 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }
        
        #svgViewerContainer.grabbing {
            cursor: grabbing !important;
        }
        
        #svgTransformContainer {
            transition: transform 0.2s ease-out;
        }
        
        #svgTransformContainer.no-transition {
            transition: none;
        }
        
        /* SVG specific styling for proper zoom */
        #svgDisplay svg {
            display: block;
            max-width: none !important;
            max-height: none !important;
            width: auto !important;
            height: auto !important;
            pointer-events: auto;
        }
        
        /* Zoom controls styling */
        .zoom-controls {
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">
    <!-- Header -->
    <div class="bg-white border-b border-gray-200">
        <div class="max-w-7xl mx-auto px-4 py-4">
            <div class="flex items-center justify-between">
                <div>
                    <h1 class="text-2xl font-bold text-gray-900">VectorCraft 2.0</h1>
                    <p class="text-gray-600">Professional raster to vector conversion with advanced algorithms</p>
                </div>
                <div class="px-3 py-1 bg-green-100 text-green-800 rounded-full text-sm font-medium">
                    ✓ Hybrid Engine Active
                </div>
            </div>
        </div>
    </div>

    <div class="max-w-7xl mx-auto px-4 py-8">
        <!-- Upload Area -->
        <div class="bg-white border border-gray-200 rounded-xl p-12 mb-8 text-center" id="uploadSection">
            <div class="upload-area border-2 border-dashed border-gray-300 rounded-lg p-16 cursor-pointer transition-colors" 
                 id="uploadArea" onclick="document.getElementById('fileInput').click()">
                <div class="w-20 h-20 mx-auto mb-6 text-gray-400">
                    <i data-lucide="upload-cloud" class="w-20 h-20"></i>
                </div>
                <h2 class="text-2xl font-semibold text-gray-900 mb-3">Upload your image</h2>
                <p class="text-gray-600 mb-4">Drag and drop or click to select an image file</p>
                <p class="text-sm text-gray-500">PNG, JPG, GIF, BMP, TIFF • Max 16MB</p>
                <input type="file" id="fileInput" accept="image/*" class="hidden">
            </div>
        </div>

        <!-- Processing State -->
        <div class="bg-white border border-gray-200 rounded-xl p-16 text-center" id="processingPanel" style="display: none;">
            <div class="w-16 h-16 mx-auto mb-6 animate-spin text-indigo-600">
                <i data-lucide="loader-2" class="w-16 h-16"></i>
            </div>
            <h2 class="text-2xl font-semibold text-gray-900 mb-3">Processing image</h2>
            <p class="text-gray-600">Converting your image to vector format...</p>
            <div class="mt-8 w-80 bg-gray-200 rounded-full h-3 mx-auto">
                <div class="bg-indigo-600 h-3 rounded-full animate-pulse" style="width: 60%"></div>
            </div>
        </div>

        <!-- Results Section -->
        <div id="resultsContainer" class="bg-white border border-gray-200 rounded-xl overflow-hidden" style="display: none;">
            <!-- Header Bar -->
            <div class="bg-gray-50 border-b border-gray-200 px-8 py-6">
                <div class="flex items-center justify-between">
                    <div class="flex items-center">
                        <h2 class="text-2xl font-semibold text-gray-900">Vector Result</h2>
                    </div>
                    
                    <div class="flex items-center gap-3">
                        <label class="flex items-center gap-2 cursor-pointer">
                            <input type="checkbox" id="showOriginalToggle" class="rounded border-gray-300 text-indigo-600 focus:ring-indigo-500">
                            <span class="text-sm text-gray-700">Show Original</span>
                        </label>
                        
                        <select id="strategySelector" class="px-3 py-2 text-sm border border-gray-300 rounded-lg bg-white text-gray-700 focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500" onchange="updateStrategy()">
                            <option value="vtracer_high_fidelity">VTracer</option>
                            <option value="experimental">🧪 Experiment</option>
                        </select>
                        
                        <button id="paletteToggle" class="flex items-center gap-2 px-4 py-2 text-sm font-medium text-white bg-purple-600 rounded-lg hover:bg-purple-700 transition-colors" style="display: none;" onclick="openColorsTab()">
                            <i data-lucide="palette" class="w-4 h-4"></i>
                            <span>Colors</span>
                        </button>
                        
                        <button id="controlsToggle" class="flex items-center gap-2 px-3 py-2 text-sm text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-50">
                            <i data-lucide="sliders" class="w-4 h-4"></i>
                            <span>Settings</span>
                        </button>
                        
                        <button onclick="uploadNewImage()" 
                                class="inline-flex items-center px-3 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-50">
                            <i data-lucide="upload" class="w-4 h-4 mr-1"></i>
                            New
                        </button>
                        
                        <button onclick="downloadSVG()" 
                                class="inline-flex items-center px-4 py-2 text-sm font-medium text-white bg-indigo-600 border border-transparent rounded-lg hover:bg-indigo-700">
                            <i data-lucide="download" class="w-4 h-4 mr-2"></i>
                            Download SVG
                        </button>
                    </div>
                </div>
            </div>
            
            <div class="flex">
                <!-- Main Display Area with Dynamic Viewer -->
                <div class="flex-1 relative bg-white" style="height: 80vh;">
                    <!-- Zoom & Pan Controls Bar -->
                    <div class="absolute top-4 left-4 z-10 bg-white shadow-lg rounded-lg p-2 flex items-center gap-2 border border-gray-200">
                        <!-- Zoom Controls -->
                        <button id="zoomOut" class="p-2 hover:bg-gray-100 rounded transition-colors" title="Zoom Out">
                            <i data-lucide="minus" class="w-4 h-4"></i>
                        </button>
                        
                        <select id="zoomPreset" class="px-2 py-1 text-sm border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500">
                            <option value="0.25">25%</option>
                            <option value="0.5">50%</option>
                            <option value="0.75">75%</option>
                            <option value="1" selected>100%</option>
                            <option value="1.5">150%</option>
                            <option value="2">200%</option>
                            <option value="4">400%</option>
                            <option value="8">800%</option>
                        </select>
                        
                        <button id="zoomIn" class="p-2 hover:bg-gray-100 rounded transition-colors" title="Zoom In">
                            <i data-lucide="plus" class="w-4 h-4"></i>
                        </button>
                        
                        <div class="w-px h-6 bg-gray-300 mx-1"></div>
                        
                        <!-- Fit Controls -->
                        <button id="fitToContainer" class="px-3 py-1 text-sm hover:bg-gray-100 rounded transition-colors" title="Fit to Container">
                            Fit
                        </button>
                        
                        <button id="actualSize" class="px-3 py-1 text-sm hover:bg-gray-100 rounded transition-colors" title="Actual Size">
                            1:1
                        </button>
                    </div>
                    
                    <!-- Zoom Info Display -->
                    <div id="zoomInfo" class="absolute top-4 right-4 z-10 bg-black bg-opacity-75 text-white px-3 py-1 rounded text-sm" style="display: none;">
                        100%
                    </div>
                    
                    <!-- SVG Viewer Container -->
                    <div id="svgViewerContainer" class="absolute inset-0 overflow-hidden cursor-grab select-none" style="background-color: #f8f9fa;">
                        <!-- Original Image (hidden by default) -->
                        <img id="originalImage" class="absolute opacity-0 transition-opacity duration-300 pointer-events-none">
                        
                        <!-- SVG Container with Transform -->
                        <div id="svgTransformContainer" class="absolute" style="transform-origin: 0 0; will-change: transform;">
                            <div id="svgDisplay" class="overflow-visible"></div>
                        </div>
                    </div>
                    
                    <!-- Loading Overlay -->
                    <div id="loadingOverlay" 
                         class="absolute inset-0 bg-white bg-opacity-90 flex items-center justify-center z-20" 
                         style="display: none;">
                        <div class="text-center">
                            <div class="w-12 h-12 mx-auto mb-4 animate-spin text-indigo-600">
                                <i data-lucide="loader-2" class="w-12 h-12"></i>
                            </div>
                            <p class="text-lg text-gray-600">Processing...</p>
                        </div>
                    </div>
                </div>
                
                <!-- Controls Sidebar -->
                <div id="controlsSidebar" class="w-96 bg-gray-50 border-l border-gray-200 overflow-y-auto" style="height: 80vh; display: none;">
                    <!-- Tab Headers -->
                    <div class="flex border-b border-gray-300 bg-white">
                        <button id="settingsTab" class="flex-1 px-4 py-3 text-sm font-medium text-gray-700 bg-white border-b-2 border-indigo-500" onclick="switchTab('settings')">
                            <i data-lucide="sliders" class="w-4 h-4 inline mr-2"></i>Settings
                        </button>
                        <button id="colorsTab" class="flex-1 px-4 py-3 text-sm font-medium text-gray-500 bg-gray-50 border-b-2 border-transparent hover:text-gray-700" onclick="switchTab('colors')">
                            <i data-lucide="palette" class="w-4 h-4 inline mr-2"></i>Colors
                        </button>
                    </div>

                    <!-- Settings Tab Content -->
                    <div id="settingsTabContent" class="p-8">
                        <div class="space-y-8">
                            <div>
                                <h3 class="text-lg font-semibold text-gray-900 mb-6">Adjust Parameters</h3>
                            </div>
                        
                        <!-- Quality Control -->
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-4">Quality</label>
                            <input type="range" id="filterSpeckle" min="1" max="10" value="4" class="w-full slider" oninput="updateParameterValue('filterSpeckle', this.value); updatePreview();">
                            <div class="flex justify-between text-sm text-gray-500 mt-2">
                                <span>Fast</span>
                                <span id="filterSpeckleValue" class="font-medium text-indigo-600">4</span>
                                <span>Best</span>
                            </div>
                        </div>
                        
                        <!-- Detail Level -->
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-4">Detail Level</label>
                            <input type="range" id="colorPrecision" min="1" max="16" value="8" class="w-full slider" oninput="updateParameterValue('colorPrecision', this.value); updatePreview();">
                            <div class="flex justify-between text-sm text-gray-500 mt-2">
                                <span>Simple</span>
                                <span id="colorPrecisionValue" class="font-medium text-indigo-600">8</span>
                                <span>Detailed</span>
                            </div>
                        </div>
                        
                        <!-- Smoothness -->
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-4">Smoothness</label>
                            <input type="range" id="cornerThreshold" min="0" max="180" value="90" class="w-full slider" oninput="updateParameterValue('cornerThreshold', this.value); updatePreview();">
                            <div class="flex justify-between text-sm text-gray-500 mt-2">
                                <span>Sharp</span>
                                <span id="cornerThresholdValue" class="font-medium text-indigo-600">90</span>
                                <span>Smooth</span>
                            </div>
                        </div>
                        
                        <!-- Advanced Settings -->
                        <details class="border-t border-gray-300 pt-6">
                            <summary class="text-sm font-medium text-gray-700 cursor-pointer mb-4">Advanced Settings</summary>
                            <div class="space-y-6">
                                <div>
                                    <label class="block text-sm font-medium text-gray-700 mb-3">Layer Difference</label>
                                    <input type="range" id="layerDifference" min="1" max="50" value="8" class="w-full slider" oninput="updateParameterValue('layerDifference', this.value); updatePreview();">
                                    <div class="flex justify-between text-sm text-gray-500 mt-2">
                                        <span>1</span>
                                        <span id="layerDifferenceValue" class="font-medium text-indigo-600">8</span>
                                        <span>50</span>
                                    </div>
                                </div>
                                
                                <div>
                                    <label class="block text-sm font-medium text-gray-700 mb-3">Length Threshold</label>
                                    <input type="range" id="lengthThreshold" min="0.5" max="20" value="1.0" step="0.1" class="w-full slider" oninput="updateParameterValue('lengthThreshold', this.value); updatePreview();">
                                    <div class="flex justify-between text-sm text-gray-500 mt-2">
                                        <span>0.5</span>
                                        <span id="lengthThresholdValue" class="font-medium text-indigo-600">1.0</span>
                                        <span>20</span>
                                    </div>
                                </div>
                                
                                <div>
                                    <label class="block text-sm font-medium text-gray-700 mb-3">Splice Threshold</label>
                                    <input type="range" id="spliceThreshold" min="0" max="100" value="20" class="w-full slider" oninput="updateParameterValue('spliceThreshold', this.value); updatePreview();">
                                    <div class="flex justify-between text-sm text-gray-500 mt-2">
                                        <span>0</span>
                                        <span id="spliceThresholdValue" class="font-medium text-indigo-600">20</span>
                                        <span>100</span>
                                    </div>
                                </div>
                            </div>
                        </details>
                        
                        <!-- Quick Actions -->
                        <div class="border-t border-gray-300 pt-6">
                            <div class="grid grid-cols-2 gap-4">
                                <button onclick="resetParameters()" class="px-4 py-3 text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-50 font-medium">
                                    Reset
                                </button>
                                <button onclick="setOptimalParameters()" class="px-4 py-3 text-white bg-indigo-600 rounded-lg hover:bg-indigo-700 font-medium">
                                    Optimal
                                </button>
                            </div>
                        </div>
                        </div>
                    </div>

                    <!-- Colors Tab Content -->
                    <div id="colorsTabContent" class="p-8" style="display: none;">
                        <div class="space-y-6">
                            <div>
                                <h3 class="text-lg font-semibold text-gray-900 mb-4">Color Palettes</h3>
                                <p class="text-sm text-gray-600 mb-6">Choose colors detected in your image. Click to preview, then apply.</p>
                            </div>

                            <!-- Suggested Palettes Section -->
                            <div class="space-y-4">
                                <h4 class="text-base font-medium text-gray-900">Suggested Palettes</h4>
                                <div id="suggestedPalettesIntegrated" class="space-y-3">
                                    <!-- Detected color palettes will appear here -->
                                </div>
                                
                                <div class="pt-4 border-t border-gray-200">
                                    <button id="applySelectedPaletteIntegrated" onclick="applySelectedPalette()" disabled class="w-full px-4 py-2 text-sm font-medium text-white bg-indigo-600 rounded-lg hover:bg-indigo-700 disabled:bg-gray-300 disabled:cursor-not-allowed transition-colors">
                                        Apply Selected Palette
                                    </button>
                                </div>
                                
                                <button onclick="resetToOriginalPreview()" class="w-full px-3 py-2 text-sm border border-gray-300 rounded-lg hover:bg-gray-50 text-gray-700">
                                    🔄 Reset to Original
                                </button>
                            </div>

                            <!-- Advanced Options -->
                            <details class="border-t border-gray-200 pt-6">
                                <summary class="text-sm font-medium text-gray-600 cursor-pointer mb-4 hover:text-gray-800">Advanced: Custom Palette</summary>
                                <div class="border border-gray-300 rounded-lg p-4 bg-gray-50">
                                    <div id="customPaletteColorsIntegrated" class="flex flex-wrap gap-2 mb-4 min-h-[40px]">
                                        <!-- Custom colors appear here -->
                                    </div>
                                    <div class="flex gap-2">
                                        <button onclick="addCustomColor()" class="flex-1 px-3 py-2 text-sm border border-gray-300 rounded hover:bg-gray-100 flex items-center justify-center gap-2">
                                            <i data-lucide="plus" class="w-4 h-4"></i>
                                            Add Color
                                        </button>
                                        <button onclick="previewCustomPalette()" class="flex-1 px-3 py-2 text-sm border border-indigo-300 text-indigo-600 rounded hover:bg-indigo-50">
                                            Preview
                                        </button>
                                        <button onclick="applyCustomPalette()" class="flex-1 px-3 py-2 text-sm bg-indigo-600 text-white rounded hover:bg-indigo-700">
                                            Apply
                                        </button>
                                    </div>
                                    <p class="text-xs text-gray-500 mt-2">Select a color above to change it.<br>Click in image to set the color (ctrl-click to blend).</p>
                                </div>
                            </details>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>


    <!-- Color Picker Modal -->
    <div id="colorPickerModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center" style="display: none; z-index: 1001;">
        <div class="bg-white rounded-lg shadow-xl p-6">
            <h3 class="text-lg font-semibold mb-4">Pick a Color</h3>
            <input type="color" id="colorPicker" class="w-full h-32 border border-gray-300 rounded">
            <div class="flex gap-3 mt-4">
                <button onclick="closeColorPicker()" class="px-4 py-2 text-sm border border-gray-300 rounded hover:bg-gray-100">Cancel</button>
                <button onclick="confirmColor()" class="px-4 py-2 text-sm bg-indigo-600 text-white rounded hover:bg-indigo-700">Add Color</button>
            </div>
        </div>
    </div>

    <!-- Hidden form fields -->
    <input type="hidden" id="vectorizerType" value="optimized">
    <input type="hidden" id="strategy" value="vtracer_high_fidelity">
    <input type="hidden" id="targetTime" value="60">

    <script>
        // Initialize Lucide icons
        lucide.createIcons();

        // State management
        let currentImageFile = null;
        let currentDownloadUrl = null;
        let extractedPalettes = null;
        let selectedPalette = null;
        let customPalette = [];

        // Tab switching functionality
        function switchTab(tabName) {
            console.log('🔄 Switching to tab:', tabName);
            
            // Update tab buttons
            const settingsTab = document.getElementById('settingsTab');
            const colorsTab = document.getElementById('colorsTab');
            const settingsContent = document.getElementById('settingsTabContent');
            const colorsContent = document.getElementById('colorsTabContent');

            if (tabName === 'settings') {
                // Activate settings tab
                settingsTab.className = 'flex-1 px-4 py-3 text-sm font-medium text-gray-700 bg-white border-b-2 border-indigo-500';
                colorsTab.className = 'flex-1 px-4 py-3 text-sm font-medium text-gray-500 bg-gray-50 border-b-2 border-transparent hover:text-gray-700';
                settingsContent.style.display = 'block';
                colorsContent.style.display = 'none';
            } else if (tabName === 'colors') {
                // Activate colors tab
                settingsTab.className = 'flex-1 px-4 py-3 text-sm font-medium text-gray-500 bg-gray-50 border-b-2 border-transparent hover:text-gray-700';
                colorsTab.className = 'flex-1 px-4 py-3 text-sm font-medium text-gray-700 bg-white border-b-2 border-indigo-500';
                settingsContent.style.display = 'none';
                colorsContent.style.display = 'block';
                
                // Auto-extract palettes when opening colors tab if not already done
                if (currentImageFile && !extractedPalettes) {
                    console.log('🎨 Auto-extracting palettes for colors tab...');
                    extractColorPalettes();
                }
            }
            
            // Refresh icons
            lucide.createIcons();
        }

        // File upload handling
        document.getElementById('fileInput').addEventListener('change', handleFileSelect);
        
        // Drag and drop
        const uploadArea = document.getElementById('uploadArea');
        
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('border-indigo-400', 'bg-indigo-50');
        });
        
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('border-indigo-400', 'bg-indigo-50');
        });
        
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('border-indigo-400', 'bg-indigo-50');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                document.getElementById('fileInput').files = files;
                handleFileSelect({ target: { files: files } });
            }
        });

        // Open Colors Tab function
        function openColorsTab() {
            console.log('🎨 Opening Colors tab...');
            const sidebar = document.getElementById('controlsSidebar');
            const controlsToggle = document.getElementById('controlsToggle');
            
            // Show sidebar if hidden
            if (sidebar.style.display === 'none') {
                sidebar.style.display = 'block';
                controlsToggle.innerHTML = '<i data-lucide="x" class="w-5 h-5"></i><span>Close</span>';
            }
            
            // Switch to colors tab
            switchTab('colors');
            lucide.createIcons();
        }

        // Controls toggle - updated for tabbed interface
        document.getElementById('controlsToggle').addEventListener('click', function() {
            const sidebar = document.getElementById('controlsSidebar');
            if (sidebar.style.display === 'none') {
                sidebar.style.display = 'block';
                this.innerHTML = '<i data-lucide="x" class="w-5 h-5"></i><span>Close</span>';
                // Default to settings tab when opening
                switchTab('settings');
            } else {
                sidebar.style.display = 'none';
                this.innerHTML = '<i data-lucide="sliders" class="w-5 h-5"></i><span>Settings</span>';
            }
            lucide.createIcons();
        });

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                currentImageFile = file;
                processImage(file);
            }
        }

        function processImage(file) {
            showProcessing();
            
            const formData = new FormData();
            formData.append('file', file);
            formData.append('vectorizer', document.getElementById('vectorizerType').value);
            formData.append('target_time', document.getElementById('targetTime').value);
            formData.append('strategy', document.getElementById('strategy').value);
            
            // Add VTracer parameters
            addVTracerParams(formData);

            fetch('/api/vectorize', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    displayResults(data, file);
                } else {
                    showError(data.error || 'Processing failed');
                }
            })
            .catch(error => {
                console.error('Error:', error);
                showError('Network error: ' + error.message);
            });
        }

        function addVTracerParams(formData) {
            formData.append('filter_speckle', document.getElementById('filterSpeckle').value);
            formData.append('color_precision', document.getElementById('colorPrecision').value);
            formData.append('layer_difference', document.getElementById('layerDifference').value);
            formData.append('corner_threshold', document.getElementById('cornerThreshold').value);
            formData.append('length_threshold', document.getElementById('lengthThreshold').value);
            formData.append('splice_threshold', document.getElementById('spliceThreshold').value);
            formData.append('curve_fitting', 'spline');
        }

        function showProcessing() {
            document.getElementById('uploadSection').style.display = 'none';
            document.getElementById('processingPanel').style.display = 'block';
            document.getElementById('resultsContainer').style.display = 'none';
        }

        function displayResults(data, file) {
            // Hide processing and upload
            document.getElementById('processingPanel').style.display = 'none';
            document.getElementById('uploadSection').style.display = 'none';
            document.getElementById('loadingOverlay').style.display = 'none';
            
            // Show results
            document.getElementById('resultsContainer').style.display = 'block';
            
            // Display original image only once (not on parameter updates)
            if (!document.getElementById('originalImage').src) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    document.getElementById('originalImage').src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
            
            // Auto-extract palettes for experimental mode
            const strategy = document.getElementById('strategy').value;
            if (strategy === 'experimental' && !extractedPalettes) {
                console.log('🎨 Auto-extracting palettes for experimental mode...');
                setTimeout(() => {
                    extractColorPalettes();
                }, 500); // Small delay to ensure UI is ready
            }
            
            // Display SVG result using professional viewer
            console.log('🖼️ Displaying SVG result, content exists:', !!data.svg_content);
            console.log('🖼️ SVG content length:', data.svg_content ? data.svg_content.length : 0);
            
            if (data.svg_content) {
                console.log('🖼️ SVG preview:', data.svg_content.substring(0, 200));
                
                // Use our professional SVG viewer
                if (!svgViewer) {
                    svgViewer = new SVGViewer();
                }
                svgViewer.setSVGContent(data.svg_content);
            } else {
                console.error('❌ No SVG content in response!');
                console.log('📄 Full response data:', data);
            }
            
            // Store download URL
            currentDownloadUrl = data.download_url;
            console.log('🔗 Updated download URL:', currentDownloadUrl);
            
            // Stats display removed for cleaner UI
            
            // Initialize before/after toggle only once
            if (!document.getElementById('showOriginalToggle').hasEventListener) {
                initializeBeforeAfterToggle();
                document.getElementById('showOriginalToggle').hasEventListener = true;
            }
        }

        // Stats display functions removed for cleaner UI
        
        function initializeBeforeAfterToggle() {
            const toggle = document.getElementById('showOriginalToggle');
            const originalImage = document.getElementById('originalImage');
            const svgDisplay = document.getElementById('svgDisplay');
            
            // Set initial state (show vector result)
            originalImage.style.opacity = '0';
            svgDisplay.style.opacity = '1';
            toggle.checked = false;
            
            toggle.addEventListener('change', function() {
                if (this.checked) {
                    originalImage.style.opacity = '1';
                    svgDisplay.style.opacity = '0';
                } else {
                    originalImage.style.opacity = '0';
                    svgDisplay.style.opacity = '1';
                }
            });
        }

        // Quality badge function removed for cleaner UI

        function downloadSVG() {
            if (currentDownloadUrl) {
                window.open(currentDownloadUrl, '_blank');
            }
        }

        function showError(message) {
            document.getElementById('processingPanel').style.display = 'none';
            alert('Error: ' + message);
            document.getElementById('uploadSection').style.display = 'block';
        }

        function resetParameters() {
            document.getElementById('filterSpeckle').value = 4;
            document.getElementById('colorPrecision').value = 8;
            document.getElementById('cornerThreshold').value = 90;
            document.getElementById('layerDifference').value = 8;
            document.getElementById('lengthThreshold').value = 1.0;
            document.getElementById('spliceThreshold').value = 20;
        }

        function setOptimalParameters() {
            document.getElementById('filterSpeckle').value = 6;
            document.getElementById('colorPrecision').value = 10;
            document.getElementById('cornerThreshold').value = 60;
            document.getElementById('layerDifference').value = 12;
            document.getElementById('lengthThreshold').value = 0.8;
            document.getElementById('spliceThreshold').value = 15;
            
            // Update display values
            document.getElementById('filterSpeckleValue').textContent = 6;
            document.getElementById('colorPrecisionValue').textContent = 10;
            document.getElementById('cornerThresholdValue').textContent = 60;
            document.getElementById('layerDifferenceValue').textContent = 12;
            document.getElementById('lengthThresholdValue').textContent = 0.8;
            document.getElementById('spliceThresholdValue').textContent = 15;
            
            // Trigger update if image is loaded
            if (currentImageFile) {
                updatePreview();
            }
        }
        
        function updateStrategy() {
            const strategy = document.getElementById('strategySelector').value;
            document.getElementById('strategy').value = strategy;
            console.log('Strategy updated to:', strategy);
            
            // Show/hide palette button based on strategy
            const paletteButton = document.getElementById('paletteToggle');
            if (strategy === 'experimental') {
                paletteButton.style.display = 'flex';
                // Extract palettes when switching to experimental mode
                if (currentImageFile && !extractedPalettes) {
                    console.log('🎨 Auto-extracting palettes for experimental mode...');
                    extractColorPalettes();
                }
            } else {
                paletteButton.style.display = 'none';
            }
            
            // Auto-reprocess if an image is already loaded
            if (currentImageFile) {
                updatePreview();
            }
        }

        function uploadNewImage() {
            // Reset to upload state
            document.getElementById('resultsContainer').style.display = 'none';
            document.getElementById('processingPanel').style.display = 'none';
            document.getElementById('uploadSection').style.display = 'block';
            
            // Reset file input
            document.getElementById('fileInput').value = '';
            currentImageFile = null;
            currentDownloadUrl = null;
            
            // Clear applied palette
            window.currentAppliedPalette = null;
            selectedPalette = null;
            extractedPalettes = null;
        }

        function updateParameterValue(paramName, value) {
            // Update the display value
            document.getElementById(paramName + 'Value').textContent = value;
        }

        let updateTimeout = null;
        let isProcessing = false;
        
        function updatePreview() {
            if (!currentImageFile || isProcessing) return;
            
            // Show loading overlay only if results are visible
            if (document.getElementById('resultsContainer').style.display === 'block') {
                document.getElementById('loadingOverlay').style.display = 'flex';
            }
            
            // Debounce updates to avoid too many requests
            clearTimeout(updateTimeout);
            updateTimeout = setTimeout(() => {
                if (!isProcessing) {
                    isProcessing = true;
                    processImageUpdate(currentImageFile);
                }
            }, 800);
        }

        function processImageUpdate(file) {
            const formData = new FormData();
            formData.append('file', file);
            formData.append('vectorizer', document.getElementById('vectorizerType').value);
            formData.append('target_time', document.getElementById('targetTime').value);
            
            // Check if we have an applied palette - if so, use it with parameter updates
            if (window.currentAppliedPalette && window.currentAppliedPalette.colors) {
                console.log('🎨 Parameter update with applied palette:', window.currentAppliedPalette);
                formData.append('strategy', 'experimental'); // Force experimental for palette
                formData.append('use_palette', 'true');
                formData.append('selected_palette', JSON.stringify(window.currentAppliedPalette.colors));
            } else {
                console.log('🎨 Parameter update without palette');
                formData.append('strategy', document.getElementById('strategy').value);
            }
            
            // Add VTracer parameters
            addVTracerParams(formData);

            fetch('/api/vectorize', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                isProcessing = false;
                if (data.success) {
                    displayResults(data, file);
                } else {
                    document.getElementById('loadingOverlay').style.display = 'none';
                    console.error('Update failed:', data.error);
                }
            })
            .catch(error => {
                isProcessing = false;
                document.getElementById('loadingOverlay').style.display = 'none';
                console.error('Update error:', error);
            });
        }

        // Palette Selection Functions (modal functions removed - using integrated sidebar)

        function extractColorPalettes() {
            if (!currentImageFile) {
                console.warn('❌ No image file available for palette extraction');
                return;
            }

            console.log('🎨 Extracting color palettes from:', currentImageFile.name);
            const formData = new FormData();
            formData.append('file', currentImageFile);
            formData.append('action', 'extract_palettes');

            fetch('/api/extract-palettes', {
                method: 'POST',
                body: formData
            })
            .then(response => {
                console.log('📡 Palette extraction response status:', response.status);
                return response.json();
            })
            .then(data => {
                console.log('📋 Palette extraction response:', data);
                if (data.success) {
                    extractedPalettes = data.palettes;
                    console.log('✅ Extracted palettes:', extractedPalettes);
                    displaySuggestedPalettes(extractedPalettes);
                } else {
                    console.error('❌ Palette extraction failed:', data.error);
                    alert('Failed to extract palettes: ' + data.error);
                }
            })
            .catch(error => {
                console.error('❌ Palette extraction network error:', error);
                alert('Network error during palette extraction: ' + error.message);
            });
        }

        function displaySuggestedPalettes(palettes) {
            const container = document.getElementById('suggestedPalettesIntegrated');
            container.innerHTML = '';
            console.log('🎨 Displaying palettes in integrated sidebar');

            // Sort palettes by color count (Vector Magic style: fewer colors first)
            const sortedKeys = Object.keys(palettes).filter(key => key.includes('_colors')).sort((a, b) => {
                const aNum = parseInt(a.split('_')[0]);
                const bNum = parseInt(b.split('_')[0]);
                return aNum - bNum;
            });

            sortedKeys.forEach((key, index) => {
                const palette = palettes[key];
                const colorCount = key.split('_')[0];
                console.log('🎨 Creating palette row for key:', key, 'colorCount:', colorCount, 'actual palette length:', palette.length);
                
                const paletteRow = document.createElement('div');
                paletteRow.className = 'p-3 border border-gray-200 rounded-lg hover:border-indigo-400 cursor-pointer transition-all duration-200';
                
                // Add blue highlight arrow for recommended palette (like Vector Magic)
                if (colorCount === '6') {
                    paletteRow.classList.add('border-indigo-500', 'bg-indigo-50');
                    
                    // Add the blue arrow indicator
                    const arrow = document.createElement('div');
                    arrow.innerHTML = '▶';
                    arrow.className = 'absolute -left-1 top-1/2 transform -translate-y-1/2 text-indigo-600 text-lg';
                    paletteRow.style.position = 'relative';
                    paletteRow.appendChild(arrow);
                }
                
                paletteRow.onclick = () => {
                    console.log('🎨 Palette clicked:', key, 'colorCount:', colorCount, 'palette length:', palette.length);
                    selectPalette(palette, `${colorCount} Colors`, paletteRow);
                    generatePalettePreview(palette);
                    
                    // Enable apply button when palette is selected
                    const applyBtn = document.getElementById('applySelectedPaletteIntegrated');
                    applyBtn.disabled = false;
                    applyBtn.textContent = `Apply ${colorCount} Colors`;
                    console.log('🎨 Apply button text set to:', applyBtn.textContent);
                };

                // Color swatches in a single row (Vector Magic style)
                const swatchContainer = document.createElement('div');
                swatchContainer.className = 'flex gap-0'; // No gap between colors like Vector Magic
                
                palette.forEach((color, colorIndex) => {
                    const swatch = document.createElement('div');
                    swatch.className = 'w-7 h-7 border border-gray-400'; // Smaller, more compact like Vector Magic
                    swatch.style.backgroundColor = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                    
                    // First color gets left border radius, last gets right border radius
                    if (colorIndex === 0) swatch.style.borderTopLeftRadius = '3px';
                    if (colorIndex === 0) swatch.style.borderBottomLeftRadius = '3px';
                    if (colorIndex === palette.length - 1) swatch.style.borderTopRightRadius = '3px';
                    if (colorIndex === palette.length - 1) swatch.style.borderBottomRightRadius = '3px';
                    
                    swatchContainer.appendChild(swatch);
                });

                paletteRow.appendChild(swatchContainer);
                container.appendChild(paletteRow);
            });
        }

        function selectPalette(palette, name, rowElement) {
            console.log('🎨 selectPalette called with:', name, 'palette length:', palette.length);
            
            // Clear previous selections
            document.querySelectorAll('#suggestedPalettesIntegrated > div').forEach(row => {
                row.classList.remove('ring-2', 'ring-indigo-500', 'bg-indigo-50');
                // Don't remove the recommended blue styling
                if (!row.querySelector('.text-indigo-600')) {
                    row.classList.remove('border-indigo-500');
                    row.classList.add('border-gray-200');
                }
            });
            
            // Style selected palette
            rowElement.classList.add('ring-2', 'ring-indigo-500', 'bg-indigo-50');
            
            selectedPalette = { colors: palette, name: name };
            console.log('🎨 Selected palette updated:', name, palette);
            console.log('🎨 selectedPalette variable:', selectedPalette);
        }

        function generatePalettePreview(palette) {
            if (!currentImageFile) return;
            
            console.log('🖼️ Generating real-time preview for palette:', palette);
            
            // Show loading state in main preview area
            const previewContainer = document.getElementById('svgDisplay');
            previewContainer.innerHTML = `
                <div class="flex items-center justify-center h-full text-gray-500">
                    <div class="text-center">
                        <div class="w-12 h-12 mx-auto mb-4 animate-spin text-indigo-600">
                            <i data-lucide="loader-2" class="w-12 h-12"></i>
                        </div>
                        <p class="text-lg">Generating palette preview...</p>
                    </div>
                </div>
            `;
            lucide.createIcons();
            
            const formData = new FormData();
            formData.append('file', currentImageFile);
            formData.append('selected_palette', JSON.stringify(palette));
            
            // Add timeout to prevent hanging
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
            
            fetch('/api/palette-preview', {
                method: 'POST',
                body: formData,
                signal: controller.signal
            })
            .then(response => {
                clearTimeout(timeoutId); // Clear timeout on successful response
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    // Update the preview image in the main area
                    previewContainer.innerHTML = `<img src="${data.preview_image}" class="max-w-full max-h-full object-contain p-12">`;
                    console.log('✅ Palette preview updated successfully in main area');
                } else {
                    console.error('❌ Preview generation failed:', data.error);
                    previewContainer.innerHTML = `
                        <div class="flex items-center justify-center h-full text-red-500">
                            <p class="text-lg">Preview generation failed: ${data.error}</p>
                        </div>
                    `;
                }
            })
            .catch(error => {
                clearTimeout(timeoutId); // Clear timeout on error
                console.error('❌ Preview generation error:', error);
                
                if (error.name === 'AbortError') {
                    previewContainer.innerHTML = `
                        <div class="flex items-center justify-center h-64 text-orange-500">
                            <p class="text-sm">Preview timed out - try a smaller image</p>
                        </div>
                    `;
                } else {
                    previewContainer.innerHTML = `
                        <div class="flex items-center justify-center h-64 text-red-500">
                            <p class="text-sm">Network error: ${error.message}</p>
                        </div>
                    `;
                }
            });
        }

        function applyPalette(palette, name) {
            selectedPalette = { colors: palette, name: name };
            console.log('🎨 Applying palette:', name, palette);
            console.log('🎨 Palette has', palette.length, 'colors');
            
            // Reprocess image with selected palette
            if (currentImageFile) {
                processImageWithPalette(currentImageFile, palette);
            }
        }

        function processImageWithPalette(file, palette) {
            if (document.getElementById('resultsContainer').style.display === 'block') {
                document.getElementById('loadingOverlay').style.display = 'flex';
            }

            const formData = new FormData();
            formData.append('file', file);
            formData.append('vectorizer', document.getElementById('vectorizerType').value);
            formData.append('target_time', document.getElementById('targetTime').value);
            formData.append('strategy', 'experimental'); // Force experimental strategy for palette processing
            formData.append('use_palette', 'true');
            formData.append('selected_palette', JSON.stringify(palette));
            
            console.log('🎨 FormData being sent:');
            console.log('  - strategy: experimental (forced for palette processing)');
            console.log('  - use_palette: true');
            console.log('  - selected_palette:', JSON.stringify(palette));

            // Add VTracer parameters
            addVTracerParams(formData);

            fetch('/api/vectorize', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                console.log('🎨 Palette vectorization response:', data);
                if (data.success) {
                    console.log('✅ Palette vectorization successful');
                    console.log('   Strategy used:', data.strategy_used);
                    console.log('   SVG elements:', data.num_elements);
                    console.log('   SVG content length:', data.svg_content ? data.svg_content.length : 0);
                    displayResults(data, file);
                } else {
                    document.getElementById('loadingOverlay').style.display = 'none';
                    console.error('❌ Palette vectorization failed:', data.error);
                }
            })
            .catch(error => {
                document.getElementById('loadingOverlay').style.display = 'none';
                console.error('Palette vectorization error:', error);
            });
        }

        // Custom Palette Functions
        function addCustomColor() {
            document.getElementById('colorPickerModal').style.display = 'flex';
        }

        function closeColorPicker() {
            document.getElementById('colorPickerModal').style.display = 'none';
        }

        function confirmColor() {
            const colorValue = document.getElementById('colorPicker').value;
            const rgb = hexToRgb(colorValue);
            
            if (rgb) {
                if (typeof window.editingColorIndex !== 'undefined') {
                    // Editing existing color
                    customPalette[window.editingColorIndex] = [rgb.r, rgb.g, rgb.b];
                    delete window.editingColorIndex;
                } else if (customPalette.length < 12) {
                    // Adding new color
                    customPalette.push([rgb.r, rgb.g, rgb.b]);
                }
                updateCustomPaletteDisplay();
            }
            
            closeColorPicker();
        }
        
        function rgbToHex(rgb) {
            const r = rgb[0].toString(16).padStart(2, '0');
            const g = rgb[1].toString(16).padStart(2, '0');
            const b = rgb[2].toString(16).padStart(2, '0');
            return `#${r}${g}${b}`;
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        function updateCustomPaletteDisplay() {
            const container = document.getElementById('customPaletteColorsIntegrated');
            container.innerHTML = '';

            // Always show at least 6 slots like Vector Magic
            const maxSlots = Math.max(6, customPalette.length + 1);
            
            for (let i = 0; i < maxSlots; i++) {
                const swatch = document.createElement('div');
                swatch.className = 'w-8 h-8 border border-gray-400 cursor-pointer hover:border-indigo-500 transition-colors';
                
                if (i < customPalette.length) {
                    // Existing color
                    const color = customPalette[i];
                    swatch.style.backgroundColor = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                    swatch.onclick = () => editCustomColor(i);
                    swatch.title = 'Click to edit this color';
                } else {
                    // Empty slot
                    swatch.style.backgroundColor = '#f3f4f6';
                    swatch.style.backgroundImage = 'url("data:image/svg+xml,%3csvg width=\'100%25\' height=\'100%25\' xmlns=\'http://www.w3.org/2000/svg\'%3e%3cdefs%3e%3cpattern id=\'a\' patternUnits=\'userSpaceOnUse\' width=\'8\' height=\'8\'%3e%3cpath d=\'m0 8 8-8M-2 2l4-4M6 10l4-4\' stroke-width=\'1\' stroke=\'%23e5e7eb\'/%3e%3c/pattern%3e%3c/defs%3e%3crect width=\'100%25\' height=\'100%25\' fill=\'url(%23a)\'/%3e%3c/svg%3e")';
                    swatch.onclick = () => addCustomColor();
                    swatch.title = 'Click to add a color';
                }
                
                container.appendChild(swatch);
            }
        }
        
        function editCustomColor(index) {
            // Store which color we're editing
            window.editingColorIndex = index;
            document.getElementById('colorPicker').value = rgbToHex(customPalette[index]);
            document.getElementById('colorPickerModal').style.display = 'flex';
        }

        function removeCustomColor(index) {
            customPalette.splice(index, 1);
            updateCustomPaletteDisplay();
        }

        function resetCustomPalette() {
            customPalette = [];
            updateCustomPaletteDisplay();
        }
        
        // Initialize custom palette display on page load
        document.addEventListener('DOMContentLoaded', function() {
            updateCustomPaletteDisplay();
        });

        function previewCustomPalette() {
            if (customPalette.length > 0) {
                generatePalettePreview(customPalette);
            } else {
                alert('Please add some colors to the custom palette first');
            }
        }

        function applyCustomPalette() {
            if (customPalette.length > 0) {
                applyPalette(customPalette, `Custom (${customPalette.length} colors)`);
            } else {
                alert('Please add some colors to the custom palette first');
            }
        }
        
        // Apply selected palette function
        function applySelectedPalette() {
            if (selectedPalette && selectedPalette.colors) {
                console.log('🎯 Applying selected palette:', selectedPalette);
                
                // Store that we're using a palette for future parameter adjustments
                window.currentAppliedPalette = selectedPalette;
                
                // Directly process image with palette without modal operations
                if (currentImageFile) {
                    processImageWithPalette(currentImageFile, selectedPalette.colors);
                    
                    // Close the drawer after applying
                    setTimeout(() => {
                        const sidebar = document.getElementById('controlsSidebar');
                        const controlsToggle = document.getElementById('controlsToggle');
                        sidebar.style.display = 'none';
                        controlsToggle.innerHTML = '<i data-lucide="sliders" class="w-5 h-5"></i><span>Settings</span>';
                        lucide.createIcons();
                    }, 1000); // Small delay to let user see the result first
                }
            } else {
                console.warn('❌ No palette selected');
                alert('Please select a palette first');
            }
        }

        // Reset to original preview function
        function resetToOriginalPreview() {
            if (currentImageFile) {
                console.log('🔄 Resetting to original preview');
                
                // Clear selected palette
                selectedPalette = null;
                
                // Clear applied palette for parameter adjustments
                window.currentAppliedPalette = null;
                
                // Disable apply button
                const applyBtn = document.getElementById('applySelectedPaletteIntegrated');
                applyBtn.disabled = true;
                applyBtn.textContent = 'Apply Selected Palette';
                
                // Clear palette selections
                document.querySelectorAll('#suggestedPalettesIntegrated > div').forEach(row => {
                    row.classList.remove('ring-2', 'ring-indigo-500', 'bg-indigo-50');
                });
                
                // Reprocess the image with original settings (no palette)
                processImage(currentImageFile);
            }
        }

        // =====================================================================
        // PROFESSIONAL SVG ZOOM & PAN SYSTEM
        // =====================================================================
        
        class SVGViewer {
            constructor() {
                this.zoom = 1.0;
                this.panX = 0;
                this.panY = 0;
                this.isDragging = false;
                this.lastMousePos = { x: 0, y: 0 };
                this.svgDimensions = { width: 0, height: 0 };
                this.containerDimensions = { width: 0, height: 0 };
                
                // Get DOM elements
                this.container = document.getElementById('svgViewerContainer');
                this.transformContainer = document.getElementById('svgTransformContainer');
                this.svgDisplay = document.getElementById('svgDisplay');
                this.zoomInfo = document.getElementById('zoomInfo');
                this.zoomPreset = document.getElementById('zoomPreset');
                
                this.initializeEventListeners();
                this.updateContainerDimensions();
            }
            
            initializeEventListeners() {
                // Zoom controls
                document.getElementById('zoomIn').addEventListener('click', () => this.zoomStep(1.2));
                document.getElementById('zoomOut').addEventListener('click', () => this.zoomStep(1/1.2));
                document.getElementById('fitToContainer').addEventListener('click', () => this.fitToContainer());
                document.getElementById('actualSize').addEventListener('click', () => this.setZoom(1.0));
                
                // Zoom preset dropdown
                this.zoomPreset.addEventListener('change', (e) => {
                    this.setZoom(parseFloat(e.target.value));
                });
                
                // Mouse wheel zoom
                this.container.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const delta = e.deltaY > 0 ? 1/1.1 : 1.1;
                    this.zoomAtPoint(delta, e.clientX, e.clientY);
                });
                
                // Mouse drag for panning
                this.container.addEventListener('mousedown', (e) => this.startDrag(e));
                document.addEventListener('mousemove', (e) => this.drag(e));
                document.addEventListener('mouseup', () => this.endDrag());
                
                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
                    
                    switch(e.key) {
                        case '+':
                        case '=':
                            if (e.ctrlKey || e.metaKey) {
                                e.preventDefault();
                                this.zoomStep(1.2);
                            }
                            break;
                        case '-':
                            if (e.ctrlKey || e.metaKey) {
                                e.preventDefault();
                                this.zoomStep(1/1.2);
                            }
                            break;
                        case '0':
                            if (e.ctrlKey || e.metaKey) {
                                e.preventDefault();
                                this.fitToContainer();
                            }
                            break;
                    }
                });
                
                // Window resize
                window.addEventListener('resize', () => {
                    this.updateContainerDimensions();
                    this.constrainPan();
                    this.updateTransform();
                });
            }
            
            updateContainerDimensions() {
                const rect = this.container.getBoundingClientRect();
                this.containerDimensions = { width: rect.width, height: rect.height };
            }
            
            setSVGContent(svgContent) {
                this.svgDisplay.innerHTML = svgContent;
                
                // Get SVG dimensions
                const svg = this.svgDisplay.querySelector('svg');
                if (svg) {
                    // Get the viewBox or use width/height attributes
                    const viewBox = svg.getAttribute('viewBox');
                    if (viewBox) {
                        const [x, y, width, height] = viewBox.split(' ').map(parseFloat);
                        this.svgDimensions = { width, height };
                    } else {
                        const width = parseFloat(svg.getAttribute('width')) || 800;
                        const height = parseFloat(svg.getAttribute('height')) || 600;
                        this.svgDimensions = { width, height };
                    }
                    
                    // Remove any existing width/height constraints
                    svg.removeAttribute('width');
                    svg.removeAttribute('height');
                    svg.style.width = this.svgDimensions.width + 'px';
                    svg.style.height = this.svgDimensions.height + 'px';
                    
                    // Auto-fit the SVG to container
                    this.fitToContainer();
                }
            }
            
            zoomStep(factor) {
                const newZoom = this.zoom * factor;
                this.setZoom(newZoom);
            }
            
            zoomAtPoint(factor, clientX, clientY) {
                const rect = this.container.getBoundingClientRect();
                const pointX = clientX - rect.left;
                const pointY = clientY - rect.top;
                
                // Calculate the point in SVG space before zoom
                const svgX = (pointX - this.panX) / this.zoom;
                const svgY = (pointY - this.panY) / this.zoom;
                
                // Apply zoom
                const newZoom = Math.max(0.1, Math.min(20, this.zoom * factor));
                
                // Adjust pan to keep the point under the cursor
                this.panX = pointX - svgX * newZoom;
                this.panY = pointY - svgY * newZoom;
                this.zoom = newZoom;
                
                this.constrainPan();
                this.updateTransform();
                this.updateUI();
            }
            
            setZoom(newZoom) {
                newZoom = Math.max(0.1, Math.min(20, newZoom));
                
                // Center the zoom
                const centerX = this.containerDimensions.width / 2;
                const centerY = this.containerDimensions.height / 2;
                
                const svgCenterX = this.svgDimensions.width / 2;
                const svgCenterY = this.svgDimensions.height / 2;
                
                this.panX = centerX - svgCenterX * newZoom;
                this.panY = centerY - svgCenterY * newZoom;
                this.zoom = newZoom;
                
                this.constrainPan();
                this.updateTransform();
                this.updateUI();
            }
            
            fitToContainer() {
                if (this.svgDimensions.width === 0 || this.svgDimensions.height === 0) return;
                
                const padding = 40; // Padding around the SVG
                const availableWidth = this.containerDimensions.width - padding * 2;
                const availableHeight = this.containerDimensions.height - padding * 2;
                
                const scaleX = availableWidth / this.svgDimensions.width;
                const scaleY = availableHeight / this.svgDimensions.height;
                const scale = Math.min(scaleX, scaleY);
                
                this.zoom = scale;
                
                // Center the SVG
                this.panX = (this.containerDimensions.width - this.svgDimensions.width * scale) / 2;
                this.panY = (this.containerDimensions.height - this.svgDimensions.height * scale) / 2;
                
                this.updateTransform();
                this.updateUI();
            }
            
            startDrag(e) {
                if (e.button !== 0) return; // Only left mouse button
                
                this.isDragging = true;
                this.lastMousePos = { x: e.clientX, y: e.clientY };
                this.container.classList.add('grabbing');
                this.transformContainer.classList.add('no-transition');
                
                e.preventDefault();
            }
            
            drag(e) {
                if (!this.isDragging) return;
                
                const deltaX = e.clientX - this.lastMousePos.x;
                const deltaY = e.clientY - this.lastMousePos.y;
                
                this.panX += deltaX;
                this.panY += deltaY;
                
                this.lastMousePos = { x: e.clientX, y: e.clientY };
                
                this.constrainPan();
                this.updateTransform();
            }
            
            endDrag() {
                if (!this.isDragging) return;
                
                this.isDragging = false;
                this.container.classList.remove('grabbing');
                this.transformContainer.classList.remove('no-transition');
            }
            
            constrainPan() {
                if (this.zoom <= 1) {
                    // If zoomed out, keep SVG centered
                    const centerX = this.containerDimensions.width / 2;
                    const centerY = this.containerDimensions.height / 2;
                    const svgCenterX = this.svgDimensions.width / 2;
                    const svgCenterY = this.svgDimensions.height / 2;
                    
                    this.panX = centerX - svgCenterX * this.zoom;
                    this.panY = centerY - svgCenterY * this.zoom;
                } else {
                    // If zoomed in, constrain to prevent panning too far
                    const scaledWidth = this.svgDimensions.width * this.zoom;
                    const scaledHeight = this.svgDimensions.height * this.zoom;
                    
                    const minPanX = this.containerDimensions.width - scaledWidth;
                    const maxPanX = 0;
                    const minPanY = this.containerDimensions.height - scaledHeight;
                    const maxPanY = 0;
                    
                    this.panX = Math.max(minPanX, Math.min(maxPanX, this.panX));
                    this.panY = Math.max(minPanY, Math.min(maxPanY, this.panY));
                }
            }
            
            updateTransform() {
                this.transformContainer.style.transform = 
                    `translate(${this.panX}px, ${this.panY}px) scale(${this.zoom})`;
            }
            
            updateUI() {
                // Update zoom info
                const zoomPercent = Math.round(this.zoom * 100);
                this.zoomInfo.textContent = `${zoomPercent}%`;
                this.zoomInfo.style.display = 'block';
                
                // Update zoom preset dropdown
                this.zoomPreset.value = this.zoom.toString();
                if (!this.zoomPreset.value) {
                    // If exact match not found, show custom percentage
                    const customOption = this.zoomPreset.querySelector('option[data-custom]');
                    if (customOption) {
                        customOption.textContent = `${zoomPercent}%`;
                        customOption.value = this.zoom.toString();
                        this.zoomPreset.value = this.zoom.toString();
                    } else {
                        // Create custom option
                        const option = document.createElement('option');
                        option.value = this.zoom.toString();
                        option.textContent = `${zoomPercent}%`;
                        option.setAttribute('data-custom', 'true');
                        this.zoomPreset.appendChild(option);
                        this.zoomPreset.value = this.zoom.toString();
                    }
                }
                
                // Hide zoom info after a delay
                clearTimeout(this.hideZoomInfoTimeout);
                this.hideZoomInfoTimeout = setTimeout(() => {
                    this.zoomInfo.style.display = 'none';
                }, 2000);
            }
        }
        
        // Initialize SVG Viewer
        let svgViewer;
        
        // Override the SVG display function to use our viewer
        function displaySVGWithViewer(svgContent) {
            if (!svgViewer) {
                svgViewer = new SVGViewer();
            }
            svgViewer.setSVGContent(svgContent);
        }
        
        // Professional SVG viewer is now integrated directly into displayResults()
    </script>
</body>
</html>